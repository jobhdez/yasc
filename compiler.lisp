(defpackage :compiler
  (:use :cl))
(in-package :compiler)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; Parser
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; AST nodes
(defstruct var v)
(defstruct num n)
(defstruct bool b)
(defstruct quote-exp q)
(defstruct set! var exp)
(defstruct define name params exp)
(defstruct if-exp cnd thn els)
(defstruct lambda-exp params exp)
(defstruct let-exp bindings body)
(defstruct begin-exp exps)
(defstruct application-exp exps)

;; AST selectors and predicates
(defun variable-p (exp)
  (symbolp exp))
(defun number-p (exp)
  (numberp exp))
(defun boolean-p (exp)
  (or (equalp exp 'true)
      (equalp exp 'false)))

(defun quoted-p (exp)
  (equalp (car exp) 'quote))
(defun quoted-exp (exp)
  (car (cdr exp)))

(defun assignment-p (exp)
  (equalp (car exp) 'set!))
(defun assignment-var (exp)
  (car (cdr exp)))
(defun assignment-exp (exp)
  (car (cdr (cdr exp))))

(defun definition-p (exp)
  (equalp (car exp) 'define))
(defun definition-name (exp)
  (second exp))
(defun definition-params (exp)
  (cdr (cdr exp)))
(defun definition-exp (exp)
  (third exp))

(defun if-p (exp)
  (equalp (car exp) 'if))
(defun if-cond (exp)
  (second exp))
(defun if-then (exp)
  (third exp))
(defun if-else (exp)
  (fourth exp))

(defun lambda-p (exp)
  (equalp (car exp) 'lambda))
(defun lambda-params (exp)
  (second exp))
(defun lambda-exp (exp)
  (third exp))

(defun begin-p (exp)
  (equalp (car exp) 'begin))
(defun begin-exps (exp)
  (cdr exp))

(defun let-p (exp)
  (equalp (car exp) 'let))
(defun let-bindings (exp)
  (second exp))
(defun let-body (exp)
  (third exp))

(defun application-p (exp)
  (listp exp))
(defun application-exps (exp)
  exp)

(defun parse (exp)
  (cond ((variable-p exp)
	 (make-var :v exp))
	((number-p exp)
	 (make-num :n exp))
	((boolean-p exp)
	 (make-bool :b exp))
	((quoted-p exp)
	 (make-quote-exp :q exp))
	((assignment-p exp)
	 (make-set! :var (assignment-var exp)
		    :exp (assignment-exp exp)))
	((definition-p exp)
	 (make-define :name (definition-name exp)
		      :params (definition-params exp)
		      :exp (definition-exp exp)))
	((if-p exp)
	 (make-if-exp :cnd (parse (if-cond exp))
		      :els (parse (if-then exp))
		      :thn (parse (if-else exp))))
	((lambda-p exp)
	 (make-lambda-exp :params (lambda-params exp)
			  :exp (lambda-exp exp)))
	((let-p exp)
	 (make-let-exp :bindings (let-bindings exp)
		       :body (let-body exp)))
	((begin-p exp)
	 (make-begin-exp :exps (begin-exp-exps exp)))
	((application-p exp)
	 (if (or (equalp (first exp) '+)
		 (equalp (first exp) '<)
		 (equalp (first exp) '>)
		 (equalp (first exp) 'eq?))
	     (make-prim :op (make-var :v (first exp))
			:exps (mapcar (lambda (x) (parse x)) (cdr exp)))
	     (make-application-exp :exps (mapcar (lambda (x) (parse x)) (application-exps exp)))))
	(t (error "Unknown expression type -- PARSE ~s" exp))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; AST-TO-A-Normal-Form
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; ANF ast nodes
(defstruct let-binding bindings exp body)
(defstruct anf-var v)
(defstruct anf-num n)
(defstruct anf-quote q)
(defstruct anf-set var exp)
(defstruct anf-definition name exp)
(defstruct anf-if cnd thn els)
(defstruct anf-application exps)
(defstruct prim op exps)

(defun to-anf (exp)
  (ast-to-anf exp 0))

(defun ast-to-anf (exp counter)
  (cond ((var-p exp)
	 (make-anf-var :v (var-v exp)))
	((num-p exp)
	 (make-anf-num :n (num-n exp)))
	((bool-p exp)
	 (make-anf-bool :b (bool-b exp)))
	((quote-exp-p exp)
	 (make-anf-quote :q (quote-exp-q exp)))
	((set!-p exp)
	 (if (not (atomicp (set!-exp exp)))
	     (let ((tmp (concatenate 'string "tmp" (format nil "~a" counter))))
		   (make-let-binding :bindings (list tmp)
				     :exp exp
				     :body (make-anf-set :var (set!-var exp)
							 :exp tmp)))
	     (make-anf-set :var (set!-var exp)
			   :exp (set!-exp exp))))
	((define-p exp)
	 (make-define :name (define-name exp)
		      :params (define-params exp)
		      :exp (define-exp exp)))
	((if-exp-p exp)
	 (cond ((atomicp (if-exp-cnd exp)) exp) 
	       ((not (atomicp (if-exp-cnd exp))) 
		(let ((tmp (concatenate 'string "tmp" (format nil "~a" counter))))
		  (make-let-binding :bindings tmp
				    :exp (ast-to-anf (if-exp-cnd exp) (+ counter 1))
				    :body (make-anf-if :cnd tmp
						       :thn (ast-to-anf (if-exp-thn exp) (+ counter 2))
						       :els (ast-to-anf (if-exp-els exp) (+ counter 3))))))))
	((lambda-exp-p exp)
	 (make-anf-lambda :params (lambda-exp-params exp)
			  :exp (ast-to-anf (lambda-exp-exp exp)) (+ counter 1)))
	((let-exp-p exp)
	 (let* ((bindings (let-exp-bindings exp))
		(vars (mapcar (lambda (x) (first x)) bindings))
		(exps (mapcar (lambda (x) (second x)) bindings))
		(body (let-exp-body exp))
		(lam (make-lambda-exp :params vars :exp body)))
	   (ast-to-anf (make-application-exp :exps (list lam exps)) (+ counter 1))))
	   
	((prim-p exp)
	 (make-prim :op (prim-op exp) :exps (prim-exps exp)))
	((application-exp-p exp)
	 (if (atomicp (first (application-exp-exps exp)))
	     (ast-to-anf (first (application-exp-exps exp)) (+ counter 1))
	     (make-let-binding :bindings (list (concatenate 'string "tmp" (format nil "~a" counter)))
		               :exp (ast-to-anf (first (anf-application-exps exp)) (+ counter 1))
		               :body (ast-to-anf (make-anf-application :exps (cdr (application-exp-exps exp))) (+ counter 1)))))
	(t (error "Unknown expression type -- AST-TO-ANF ~s" exp))))
		       
(defun atomicp (exp)
  (cond ((var-p exp) T)
	((num-p exp) T)
	((numberp exp) T)
	((stringp exp) T)
	((symbolp exp) T)
	(t Nil)))
