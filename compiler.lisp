(defpackage :compiler
  (:use :cl))
(in-package :compiler)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; Parser
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; AST nodes
(defstruct var v)
(defstruct num n)
(defstruct bool b)
(defstruct quote-exp q)
(defstruct set! var exp)
(defstruct define name params exp)
(defstruct if-exp cnd thn els)
(defstruct lambda-exp params exp)
(defstruct let-exp bindings body)
(defstruct begin-exp exps)
(defstruct application-exp exps)

;; AST selectors and predicates
(defun variable-p (exp)
  (symbolp exp))
(defun number-p (exp)
  (numberp exp))
(defun boolean-p (exp)
  (or (equalp exp 'true)
      (equalp exp 'false)))

(defun quoted-p (exp)
  (equalp (car exp) 'quote))
(defun quoted-exp (exp)
  (second exp))

(defun assignment-p (exp)
  (equalp (first exp) 'set!))
(defun assignment-var (exp)
  (second exp))
(defun assignment-exp (exp)
  (third exp))

(defun definition-p (exp)
  (equalp (first exp) 'define))
(defun definition-name (exp)
  (second exp))
(defun definition-params (exp)
  (cdr (cdr exp)))
(defun definition-exp (exp)
  (third exp))

(defun if-p (exp)
  (equalp (first exp) 'if))
(defun if-cond (exp)
  (second exp))
(defun if-then (exp)
  (third exp))
(defun if-else (exp)
  (fourth exp))

(defun lambda-p (exp)
  (equalp (first exp) 'lambda))
(defun lambda-params (exp)
  (second exp))
(defun lambda-exp (exp)
  (third exp))

(defun begin-p (exp)
  (equalp (first exp) 'begin))
(defun begin-exps (exp)
  (cdr exp))

(defun let-p (exp)
  (equalp (first exp) 'let))
(defun let-bindings (exp)
  (second exp))
(defun let-body (exp)
  (third exp))

(defun application-p (exp)
  (listp exp))
(defun application-exps (exp)
  exp)

(defun parse (exp)
  (cond ((boolean-p exp)
	 (make-bool :b exp))
	((variable-p exp)
	 (make-var :v exp))
	((number-p exp)
	 (make-num :n exp))
	((quoted-p exp)
	 (make-quote-exp :q (parse (quoted-exp exp))))
	((assignment-p exp)
	 (make-set! :var (parse (assignment-var exp))
		    :exp (parse (assignment-exp exp))))
	((definition-p exp)
	 (make-define :name (parse (definition-name exp))
		      :params (definition-params exp)
		      :exp (parse (definition-exp exp))))
	((if-p exp)
	 (make-if-exp :cnd (parse (if-cond exp))
		      :els (parse (if-then exp))
		      :thn (parse (if-else exp))))
	((lambda-p exp)
	 (make-lambda-exp :params (lambda-params exp)
			  :exp (parse (lambda-exp exp))))
	((let-p exp)
	 (let* ((bindings (let-bindings exp))
		(vars (mapcar (lambda (x) (parse (first x))) bindings))
		(exps (mapcar (lambda (x) (parse (second x))) bindings))
		(body (parse (let-body exp)))
		(lam (make-lambda-exp :params vars :exp body)))
	   (make-application-exp :exps (append (list lam) exps))))
	((begin-p exp)
	 (make-begin-exp :exps (mapcar (lambda (x) (parse x)) (begin-exp-exps exp))))
	((application-p exp)
	 (if (or (equalp (first exp) '+)
		 (equalp (first exp) '<)
		 (equalp (first exp) '>)
		 (equalp (first exp) 'eq?))
	     (make-prim :op (make-var :v (first exp))
			:exps (mapcar (lambda (x) (parse x)) (cdr exp)))
	     (make-application-exp :exps (mapcar (lambda (x) (parse x)) (application-exps exp)))))
	(t (error "Unknown expression type -- PARSE ~s" exp))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; AST-TO-A-Normal-Form
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; ANF ast nodes
(defstruct let-binding bindings exp body)
(defstruct anf-var v)
(defstruct anf-num n)
(defstruct anf-bool b)
(defstruct anf-quote q)
(defstruct anf-set var exp)
(defstruct anf-definition name exp)
(defstruct anf-lambda params exp)
(defstruct anf-if cnd thn els)
(defstruct anf-application exps)
(defstruct prim op exps)

(defun to-anf (exp)
  (ast-to-anf exp 0))

(defun ast-to-anf (exp counter)
  (cond ((bool-p exp)
	 (make-anf-bool :b (bool-b exp)))
	((var-p exp)
	 (make-anf-var :v (var-v exp)))
	((num-p exp)
	 (make-anf-num :n (num-n exp)))
	((quote-exp-p exp)
	 (make-anf-quote :q (ast-to-anf (quote-exp-q exp) counter)))
	((set!-p exp)
	 (if (not (atomicp (set!-exp exp)))
	     (let ((tmp (make-anf-var :v (concatenate 'string "tmp" (format nil "~a" counter)))))
		   (make-let-binding :bindings (list tmp)
				     :exp (ast-to-anf (set!-exp exp) (+ counter 1))
				     :body (make-anf-set :var (ast-to-anf (set!-var exp) (+ counter 1))
							 :exp tmp)))
	     (make-anf-set :var (ast-to-anf (set!-var exp) (+ counter 1))
			   :exp (ast-to-anf (set!-exp exp) (+ counter 1)))))
	((define-p exp)
	 (make-anf-definition :name (ast-to-anf (define-name exp) counter)
		              :params (define-params exp)
		              :exp (ast-to-anf (define-exp exp) counter)))
	((if-exp-p exp)
	 (cond ((atomicp (if-exp-cnd exp)) exp) 
	       ((not (atomicp (if-exp-cnd exp))) 
		(let ((tmp (make-anf-var :v (concatenate 'string "tmp" (format nil "~a" counter)))))
		  (make-let-binding :bindings (list tmp)
				    :exp (ast-to-anf (if-exp-cnd exp) (+ counter 1))
				    :body (make-anf-if :cnd tmp
						       :thn (ast-to-anf (if-exp-thn exp) (+ counter 2))
						       :els (ast-to-anf (if-exp-els exp) (+ counter 3))))))))
	((lambda-exp-p exp)
	 (make-anf-lambda :params (lambda-exp-params exp)
			  :exp (ast-to-anf (lambda-exp-exp exp) (+ counter 1))))
	((prim-p exp)
	 (make-prim :op (prim-op exp) :exps (mapcar (lambda (x) (ast-to-anf x counter)) (prim-exps exp))))
	((application-exp-p exp)
	 (let ((exps (app-to-anf (application-exp-exps exp) counter)))
	   (make-anf-application :exps exps)))
	       
	(t (error "Unknown expression type -- AST-TO-ANF ~s" exp))))
	      
(defun app-to-anf (exps counter)
  (cond ((null exps)
	 '())
	((atomicp (first exps))
	 (cons (ast-to-anf (first exps) (+ counter 1))
	       (app-to-anf (cdr exps) (+ counter 1))))
	(t (make-let-binding :bindings (list (make-anf-var :v (concatenate 'string "tmp" (format nil counter))))
			     :exp (ast-to-anf (first exps) (+ counter + 1))
			     :body (app-to-anf (cdr exps) (+ counter 1))))))
(defun atomicp (exp)
  (cond ((var-p exp) T)
	((num-p exp) T)
	((bool-p exp) T)
	((lambda-exp-p exp) T)
	(t NIL)))
