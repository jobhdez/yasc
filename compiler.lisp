(defpackage :compiler
  (:use :cl))
(in-package :compiler)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; Parser
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; AST nodes
(defstruct var v)
(defstruct num n)
(defstruct bool b)
(defstruct quote-exp q)
(defstruct set! var exp)
(defstruct define name params exp)
(defstruct if-exp cnd thn els)
(defstruct lambda-exp params exp)
(defstruct let-exp bindings body)
(defstruct begin-exp exps)
(defstruct application-exp exps)

;; AST selectors and predicates
(defun variable-p (exp)
  (symbolp exp))
(defun number-p (exp)
  (numberp exp))
(defun boolean-p (exp)
  (or (equalp exp 'true)
      (equalp exp 'false)))

(defun quoted-p (exp)
  (equalp (car exp) 'quote))
(defun quoted-exp (exp)
  (second exp))

(defun assignment-p (exp)
  (equalp (first exp) 'set!))
(defun assignment-var (exp)
  (second exp))
(defun assignment-exp (exp)
  (third exp))

(defun definition-p (exp)
  (equalp (first exp) 'define))
(defun definition-name (exp)
  (second exp))
(defun definition-params (exp)
  (cdr (cdr exp)))
(defun definition-exp (exp)
  (third exp))

(defun if-p (exp)
  (equalp (first exp) 'if))
(defun if-cond (exp)
  (second exp))
(defun if-then (exp)
  (third exp))
(defun if-else (exp)
  (fourth exp))

(defun lambda-p (exp)
  (equalp (first exp) 'lambda))
(defun lambda-params (exp)
  (second exp))
(defun lambda-exp (exp)
  (third exp))

(defun begin-p (exp)
  (equalp (first exp) 'begin))
(defun begin-exps (exp)
  (cdr exp))

(defun let-p (exp)
  (equalp (first exp) 'let))
(defun let-bindings (exp)
  (second exp))
(defun let-body (exp)
  (third exp))

(defun application-p (exp)
  (listp exp))
(defun application-exps (exp)
  exp)

(defun parse (exp)
  (cond ((boolean-p exp)
	 (make-bool :b exp))
	((variable-p exp)
	 (make-var :v exp))
	((number-p exp)
	 (make-num :n exp))
	((quoted-p exp)
	 (make-quote-exp :q (parse (quoted-exp exp))))
	((assignment-p exp)
	 (make-set! :var (parse (assignment-var exp))
		    :exp (parse (assignment-exp exp))))
	((definition-p exp)
	 (make-define :name (parse (definition-name exp))
		      :params (definition-params exp)
		      :exp (parse (definition-exp exp))))
	((if-p exp)
	 (make-if-exp :cnd (parse (if-cond exp))
		      :els (parse (if-then exp))
		      :thn (parse (if-else exp))))
	((lambda-p exp)
	 (make-lambda-exp :params (lambda-params exp)
			  :exp (parse (lambda-exp exp))))
	((let-p exp)
	 (let* ((bindings (let-bindings exp))
		(vars (mapcar (lambda (x) (parse (first x))) bindings))
		(exps (mapcar (lambda (x) (parse (second x))) bindings))
		(body (parse (let-body exp)))
		(lam (make-lambda-exp :params vars :exp body)))
	   (make-application-exp :exps (append (list lam) exps))))
	((begin-p exp)
	 (make-begin-exp :exps (mapcar (lambda (x) (parse x)) (begin-exp-exps exp))))
	((application-p exp)
	 (if (or (equalp (first exp) '+)
		 (equalp (first exp) '<)
		 (equalp (first exp) '>)
		 (equalp (first exp) 'eq?))
	     (make-prim :op (make-var :v (first exp))
			:exps (mapcar (lambda (x) (parse x)) (cdr exp)))
	     (make-application-exp :exps (mapcar (lambda (x) (parse x)) (application-exps exp)))))
	(t (error "Unknown expression type -- PARSE ~s" exp))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; A-Normal-Form
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; ANF ast nodes
(defstruct let-binding bindings exp body)
(defstruct anf-var v)
(defstruct anf-num n)
(defstruct anf-bool b)
(defstruct anf-quote q)
(defstruct anf-set var exp)
(defstruct anf-definition name exp)
(defstruct anf-lambda params exp)
(defstruct anf-if cnd thn els)
(defstruct anf-application exps)
(defstruct prim op exps)

(defun to-anf (exp)
  (ast-to-anf exp 0))

(defun ast-to-anf (exp counter)
  (cond ((bool-p exp)
	 (make-anf-bool :b (bool-b exp)))
	((var-p exp)
	 (make-anf-var :v (var-v exp)))
	((num-p exp)
	 (make-anf-num :n (num-n exp)))
	((quote-exp-p exp)
	 (make-anf-quote :q (ast-to-anf (quote-exp-q exp) counter)))
	((set!-p exp)
	 (if (not (atomicp (set!-exp exp)))
	     (let ((tmp (make-anf-var :v (concatenate 'string "tmp" (format nil "~a" counter)))))
		   (make-let-binding :bindings (list tmp)
				     :exp (ast-to-anf (set!-exp exp) (+ counter 1))
				     :body (make-anf-set :var (ast-to-anf (set!-var exp) (+ counter 1))
							 :exp tmp)))
	     (make-anf-set :var (ast-to-anf (set!-var exp) (+ counter 1))
			   :exp (ast-to-anf (set!-exp exp) (+ counter 1)))))
	((define-p exp)
	 (make-anf-definition :name (ast-to-anf (define-name exp) counter)
		              :params (define-params exp)
		              :exp (ast-to-anf (define-exp exp) counter)))
	((if-exp-p exp)
	 (cond ((atomicp (if-exp-cnd exp)) exp) 
	       ((not (atomicp (if-exp-cnd exp))) 
		(let ((tmp (make-anf-var :v (concatenate 'string "tmp" (format nil "~a" counter)))))
		  (make-let-binding :bindings (list tmp)
				    :exp (ast-to-anf (if-exp-cnd exp) (+ counter 1))
				    :body (make-anf-if :cnd tmp
						       :thn (ast-to-anf (if-exp-thn exp) (+ counter 2))
						       :els (ast-to-anf (if-exp-els exp) (+ counter 3))))))))
	((lambda-exp-p exp)
	 (make-anf-lambda :params (lambda-exp-params exp)
			  :exp (ast-to-anf (lambda-exp-exp exp) (+ counter 1))))
	((prim-p exp)
	 (make-prim :op (prim-op exp) :exps (mapcar (lambda (x) (ast-to-anf x counter)) (prim-exps exp))))
	((application-exp-p exp)
	 (let ((exps (app-to-anf (application-exp-exps exp) counter)))
	   (make-anf-application :exps exps)))
	       
	(t (error "Unknown expression type -- AST-TO-ANF ~s" exp))))
	      
(defun app-to-anf (exps counter)
  (cond ((null exps)
	 '())
	((atomicp (first exps))
	 (cons (ast-to-anf (first exps) (+ counter 1))
	       (app-to-anf (cdr exps) (+ counter 1))))
	(t (make-let-binding :bindings (list (make-anf-var :v (concatenate 'string "tmp" (format nil counter))))
			     :exp (ast-to-anf (first exps) (+ counter + 1))
			     :body (app-to-anf (cdr exps) (+ counter 1))))))
(defun atomicp (exp)
  (cond ((var-p exp) T)
	((num-p exp) T)
	((bool-p exp) T)
	((lambda-exp-p exp) T)
	(t NIL)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; Closure Conversion
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun anf-to-closure (anf)
  (let ((*closures* (make-array 0 :fill-pointer t :adjustable t)))
    (to-closure anf *closures* 0)))

(defun to-closure (anf *closures* counter)
  (cond ((anf-bool-p anf)
	 anf)
	((anf-var-p anf)
	 anf)
	((anf-num-p anf)
	 anf)
	((anf-quote-p anf)
	 anf)
	((anf-set-p anf)
	 (let* ((exp (anf-set-exp anf))
		(cls-exp (to-closure anf *closures*)))
	   (make-anf-set :var (anf-set-var anf)
			 :exp cls-exp)))
	((anf-if-p anf)
	 (make-anf-if :cnd (to-closure (anf-if-cnd anf) *closures* counter)
		      :thn (to-closure (anf-if-thn anf) *closures* counter)
		      :els (to-closure (anf-if-els anf) *closures* counter)))
	((anf-lambda-p anf)
	 (let* ((fvs (free-variables (anf-lambda-params anf) anf))
		(name (concatenate 'string "lambda" (format nil counter)))
		(arity  (length (anf-lambda-params anf)))
		(clos (make-closure :arity arity
			            :funref (make-funref :name name :arity arity)
			            :fvs fvs)))
	   (dolist (x fvs)
	     (vector-push-extend x *closures*))
	     (list clos
		 (make-high-level-function name fvs
					   (anf-lambda-body anf)
					   *closures*))))
	((anf-definition-p anf)
	 (to-closure (anf-definition-exp anf) (+ counter 1)))))
	 

(defun make-high-level-function (name fvs counter index body)
  (if (null fvs)
      body
      (let ((fv (concatenate 'string "fvs" (format nil counter))))
	(make-let-binding :binding (list fv)
			  :exp (list (aref closures index))
			  :body (make-high-level-function name
							  (cdr fvs)
							  (+ counter 1)
							  (+ index 1))))))

(defun free-variables (vars anf)
  (cond ((anf-if-p anf)
	 (append (free-varibles (anf-if-cnd vars anf))
	         (free-variables (anf-if-thn vars anf))
		 (free-variables (anf-if-cnd vars anf))))
	((prim-p anf)
	 (let ((fvs1 (if (member (first (prim-exps anf)) vars)
			'() (list (first (prim-exps anf)))))
	       (fvs2 (if (member (second (prim-exps anf)) vars)
			 '() (list (first (prim-exps anf))))))
	   (append fvs1 fvs2)))
	((anf-lambda-p anf)
	 (remove-if (lambda (v) (member v vars))
		    (free-variables vars (anf-lambda-exp anf))))))
