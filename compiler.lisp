(defpackage :compiler
  (:use :cl))
(in-package :compiler)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; Parser
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; AST nodes
(defstruct var v)
(defstruct num n)
(defstruct bool b)
(defstruct quote-exp q)
(defstruct set! var exp)
(defstruct define name params exp)
(defstruct if-exp cnd thn els)
(defstruct lambda-exp params exp)
(defstruct let-exp bindings body)
(defstruct begin-exp exps)
(defstruct application-exp exps)

;; AST selectors and predicates
(defun variable-p (exp)
  (symbolp exp))
(defun number-p (exp)
  (numberp exp))
(defun boolean-p (exp)
  (or (equalp exp 'true)
      (equalp exp 'false)))

(defun quoted-p (exp)
  (equalp (car exp) 'quote))
(defun quoted-exp (exp)
  (second exp))

(defun assignment-p (exp)
  (equalp (first exp) 'set!))
(defun assignment-var (exp)
  (second exp))
(defun assignment-exp (exp)
  (third exp))

(defun definition-p (exp)
  (equalp (first exp) 'define))
(defun definition-name (exp)
  (second exp))
(defun definition-params (exp)
  (cdr (cdr exp)))
(defun definition-exp (exp)
  (third exp))

(defun if-p (exp)
  (equalp (first exp) 'if))
(defun if-cond (exp)
  (second exp))
(defun if-then (exp)
  (third exp))
(defun if-else (exp)
  (fourth exp))

(defun lambda-p (exp)
  (equalp (first exp) 'lambda))
(defun lambda-params (exp)
  (second exp))
(defun lambda-exp (exp)
  (third exp))


(defun begin-p (exp)
  (equalp (first exp) 'begin))
(defun begin-exps (exp)
  (cdr exp))

(defun let-p (exp)
  (equalp (first exp) 'let))
(defun let-bindings (exp)
  (second exp))
(defun let-body (exp)
  (third exp))

(defun application-p (exp)
  (listp exp))
(defun application-exps (exp)
  exp)

(defun parse (exp)
  (cond ((boolean-p exp)
	 (make-bool :b exp))	
	((variable-p exp)
	 (make-var :v exp))	
	((number-p exp)
	 (make-num :n exp))	
	((quoted-p exp)
	 (make-quote-exp :q (parse (quoted-exp exp))))	
	((assignment-p exp)
	 (make-set! :var (parse (assignment-var exp))
		    :exp (parse (assignment-exp exp))))	
	((definition-p exp)
	 (make-define :name (parse (definition-name exp))
		      :params (definition-params exp)
		      :exp (parse (definition-exp exp))))	
	((if-p exp)
	 (make-if-exp :cnd (parse (if-cond exp))
		      :els (parse (if-then exp))
		      :thn (parse (if-else exp))))
      	((lambda-p exp)
	 (make-lambda-exp :params (mapcar (lambda (x) (parse x)) (lambda-params exp))
			  :exp (parse (lambda-exp exp))))	
	((let-p exp)
	 (let* ((bindings (let-bindings exp))
		(vars (mapcar (lambda (x) (parse (first x))) bindings))
		(exps (mapcar (lambda (x) (parse (second x))) bindings))
		(body (parse (let-body exp)))
		(lam (make-lambda-exp :params vars :exp body)))
	   (make-application-exp :exps (append (list lam) exps))))
	((begin-p exp)
	 (make-begin-exp :exps (mapcar (lambda (x) (parse x)) (begin-exps exp))))	
	((application-p exp)
	 (if (or (equalp (first exp) '+)
		 (equalp (first exp) '<)
		 (equalp (first exp) '>)
		 (equalp (first exp) 'eq?))
	     (make-prim :op (make-var :v (first exp))
			:exps (mapcar (lambda (x) (parse x)) (cdr exp)))
	     (make-application-exp :exps (mapcar (lambda (x) (parse x)) (application-exps exp)))))	
	(t (error "Unknown expression type -- PARSE ~s" exp))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; A-normal-form
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Anf ast nodes
(defstruct let-binding bindings exp body)
(defstruct anf-var v)
(defstruct anf-num n)
(defstruct anf-bool b)
(defstruct anf-quote q)
(defstruct anf-set var exp)
(defstruct anf-definition name params exp)
(defstruct anf-lambda params exp)
(defstruct anf-if cnd thn els)
(defstruct anf-application exps)
(defstruct prim op exps)

(defun ast-to-anf (exp)
  (to-anf exp 0))

(defun to-anf (exp counter)
  (cond ((bool-p exp)
	 (make-anf-bool :b (bool-b exp)))
       	((var-p exp)
	 (make-anf-var :v (var-v exp)))	
	((num-p exp)
	 (make-anf-num :n (num-n exp)))
       	((quote-exp-p exp)
	 (make-anf-quote :q (to-anf (quote-exp-q exp) counter)))	
	((set!-p exp)
	 (if (not (atomicp (set!-exp exp)))
	     (let ((tmp (make-anf-var :v (concatenate 'string "tmp" (format nil "~a" counter)))))
		   (make-let-binding :bindings (list tmp)
				     :exp (to-anf (set!-exp exp) (+ counter 1))
				     :body (make-anf-set :var (to-anf (set!-var exp) (+ counter 1))
							 :exp tmp)))
	     (make-anf-set :var (to-anf (set!-var exp) (+ counter 1))
			   :exp (to-anf (set!-exp exp) (+ counter 1)))))
	((define-p exp)
	 (make-anf-definition :name (to-anf (define-name exp) counter)
		              :params (define-params exp)
		              :exp (to-anf (define-exp exp) counter)))
	((if-exp-p exp)
	 (cond ((atomicp (if-exp-cnd exp)) exp) 
	       ((not (atomicp (if-exp-cnd exp))) 
		(let ((tmp (make-anf-var :v (concatenate 'string "tmp" (format nil "~a" counter)))))
		  (make-let-binding :bindings (list tmp)
				    :exp (to-anf (if-exp-cnd exp) (+ counter 1))
				    :body (make-anf-if :cnd tmp
						       :thn (to-anf (if-exp-thn exp) (+ counter 2))
						       :els (to-anf (if-exp-els exp) (+ counter 3))))))))
	((lambda-exp-p exp)
	 (make-anf-lambda :params (mapcar (lambda (x) (to-anf x counter)) (lambda-exp-params exp))
			  :exp (to-anf (lambda-exp-exp exp) (+ counter 1))))	
	((prim-p exp)
	 (let ((exps (app-to-anf (prim-exps exp) counter)))
	   (make-prim :op (to-anf (prim-op exp) counter)
		      :exps (mapcar (lambda (x) (to-anf x counter)) (prim-exps exp)))))
       	((begin-exp-p exp)
	 (begin-to-anf (begin-exp-exps exp) 0))	
	((application-exp-p exp)
	 (let ((exps (app-to-anf (application-exp-exps exp) counter)))
	   (make-anf-application :exps exps)))	       
	(t (error "Unknown expression type -- TO-ANF ~s" exp))))

(defun begin-to-anf (exps counter)
  (if (null (cdr exps))
      (ast-to-anf (first (last exps)))
      (make-let-binding :bindings (list (make-anf-var :v (concatenate 'string "tmp" (format nil "~a" counter))))
			:exp (ast-to-anf (first exps))
			:body (begin-to-anf (cdr exps) (+ counter 1)))))

(defun app-to-anf (exps counter)
  (cond ((null exps)
	 '())	
	((atomicp (first exps))
	 (cons (to-anf (first exps) (+ counter 1))
	       (app-to-anf (cdr exps) (+ counter 1))))	
	(t (make-let-binding :bindings (list (make-anf-var :v (concatenate 'string "tmp" (format nil counter))))
			     :exp (ast-to-anf (first exps) (+ counter + 1))
			     :body (app-to-anf (cdr exps) (+ counter 1))))))
(defun atomicp (exp)
  (cond ((var-p exp) T)
	((num-p exp) T)
	((bool-p exp) T)
	((lambda-exp-p exp) T)
	((anf-var-p exp) T)
	((anf-num-p exp) T)
	((anf-bool-p exp) T)
	((anf-lambda-p exp) T)
	(t NIL)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; Closure Conversion
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Closure conversion nodes
(defstruct fun-ref name arity)
(defstruct closure arity funref fvs)
(defstruct clos-fn closure fn)

(defun anf-to-closure (anf)
  (let ((*closures* (make-array 0 :fill-pointer t :adjustable t)))
    (to-closure anf *closures* 0)))

(defun to-closure (anf *closures* counter)
  (cond ((anf-bool-p anf)
	 anf)	
	((anf-var-p anf)
	 anf)	
	((anf-num-p anf)
	 anf)	
	((anf-quote-p anf)
	 anf)	
	((anf-set-p anf)
	 (let* ((exp (anf-set-exp anf))
		(cls-exp (to-closure exp *closures* counter)))
	   (make-anf-set :var (anf-set-var anf)
			 :exp cls-exp)))	
	((anf-if-p anf)
	 (make-anf-if :cnd (to-closure (anf-if-cnd anf) *closures* counter)
		      :thn (to-closure (anf-if-thn anf) *closures* counter)
		      :els (to-closure (anf-if-els anf) *closures* counter)))	
	((anf-lambda-p anf)
	 (let* ((fvs (free-variables (anf-lambda-params anf) anf))
		(name (concatenate 'string "lambda" (format nil "~a" counter)))
		(arity  (length (anf-lambda-params anf)))
		(clos (make-closure :arity arity
			            :funref (make-fun-ref :name name :arity arity)
			            :fvs fvs)))
	   (dolist (x fvs)
	     (vector-push-extend x *closures*))
	   (let ((high-level-fn
		  (make-anf-definition :name name
				       :params (append fvs (anf-lambda-params anf))
				       :exp (make-high-level-function name fvs counter 0
								      (to-closure (anf-lambda-exp anf)
										  *closures* counter) 
								      *closures*))))
	     (make-clos-fn :closure clos :fn high-level-fn))))	
	((let-binding-p anf)
	 (make-let-binding :bindings (let-binding-bindings anf)
			   :exp (to-closure (let-binding-exp anf)  *closures* counter)
			   :body (to-closure (let-binding-body anf) *closures* counter)))	
	((anf-definition-p anf)
	 (to-closure (anf-definition-exp anf) (+ counter 1)))
       	((prim-p anf)
	 (make-prim :op (prim-op anf) :exps (mapcar (lambda (x) (anf-to-closure x)) (prim-exps anf))))
       	((anf-application-p anf)
	 (let ((exps (anf-application-exps anf)))
	   (mapcar (lambda (x) (anf-to-closure x)) exps)))))

(defun make-high-level-function (name fvs counter index lam-exp closures)
  (if (null fvs)
      lam-exp
      (let ((fv (concatenate 'string "fvs" (format nil "~a" counter))))
	(make-let-binding :bindings (list fv)
			  :exp (list (aref closures index))
			  :body (make-high-level-function name (cdr fvs) (+ counter 1)
							  (+ index 1) lam-exp closures)))))
(defun free-variables (vars anf)
  (cond ((anf-if-p anf)
	 (append (free-varibles (anf-if-cnd vars anf))
	         (free-variables (anf-if-thn vars anf))
		 (free-variables (anf-if-cnd vars anf))))
	((prim-p anf)
	 (let ((fvs1 (if (member (first (prim-exps anf)) vars)
			'() (list (first (prim-exps anf)))))
	       (fvs2 (if (member (second (prim-exps anf)) vars)
			 '() (list (first (prim-exps anf))))))
	   (append fvs1 fvs2)))
	((anf-lambda-p anf)
	 (remove-if (lambda (v) (member v vars))
		    (free-variables vars (anf-lambda-exp anf))))	
	((anf-set-p anf)
	 (free-variables (anf-set-exp anf)))
       	((anf-definition-p anf)
	 (free-variables (anf-definition-params anf)
			 (anf-definition-exp anf)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;; Instructor Selector
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; X86 ast nodes
(defstruct immediate imm)
(defstruct stack-location stk)
(defstruct register reg)

(defstruct blocks blks)
(defstruct *block* label instructions)

(defstruct movq e1 e2)
(defstruct addq e1 e2)
(defstruct subq e1 e2)
(defstruct cmpq e1 e2)

(defun closure-to-select (cls)
  (to-select cls 0))

(defun to-select (cls counter)
  (cond ((anf-bool-p cls)
	 (if (equalp (anf-bool-b cls) 'true)
	     (make-immediate :imm (make-anf-num :n 1))
	     (make-immediate :imm (make-anf-num :n 0))))	
	((anf-num-p cls)
	 (make-immediate :imm cls))	
	((anf-var-p cls)
	 (make-stack-location :stk cls))	
	((anf-quote-p cls)
	 (to-select (quote-exp cls) counter))	
	((anf-set-p cls)
	 (let ((e1 (anf-set-exp cls)))
	   (cond ((or (anf-num-p e1) (anf-var-p e1) (anf-bool-p e1))
		  (gen-atomic e1 (anf-set-var cls)))
		 ((prim-p e1)
		   (let ((v1 (anf-var-v (prim-op e1))))
		    (cond ((equalp '+ v1)
			   (append (list (gen-prim-add b1 (prim-exps e1) 0)
					 (to-select body counter))))
			  ((equalp '- v1)
			   (append (list (gen-prim-sub b1 (prim-exps e1) 0)
					 (to-select body counter))))
			  (t
			   (append (list (gen-prim-cmp b1 (prim-exps e1) 0)
					 (to-select body counter)))))))	 
		 ((anf-if-p e1)
		  (list (gen-if-cnd (anf-if-cnd e1) counter)
			(gen-if (anf-if-thn e1) (anf-set-var cls))
			(gen-if (anf-if-els e1) (anf-set-var cls)))) 
		 ((let-binding-p cls)
		   (let ((b2 (first (let-binding-bindings cls))))
		     (append (list (to-select (let-binding-exp cls) counter)
				  (gen-mov (anf-set-var b2))
				  (to-select (let-binding-body e1) counter))))))))	
	((anf-if-p cls)
	 (let ((v1 (concatenate 'string "tmp" (format nil "~a" counter))))
	   (append (list (gen-if-cnd (anf-if-cnd cls) counter)
			 (to-select (anf-if-thn cls) counter)
			 (to-select (anf-if-els cls) counter)))))	 
	((let-binding-p cls)
	 (let* ((e1 (let-binding-exp cls))
		(b1 (car (let-binding-bindings cls)))
		(body (let-binding-body cls)))
	   (cond ((or (anf-num-p e1) (anf-var-p e1) (anf-bool-p e1)) 
		  (append (list (gen-atomic e1 b1)
				(to-select body (+ counter 1)))))
		 ((prim-p e1)
		  (let ((v1 (anf-var-v (prim-op e1))))
		    (cond ((equalp '+ v1)
			   (append (list (gen-prim-add b1 (prim-exps e1) 0)
					 (to-select body counter))))
			  ((equalp '- v1)
			   (append (list (gen-prim-sub b1 (prim-exps e1) 0)
					 (to-select body counter))))
			  (t
			   (append (list (gen-prim-cmp b1 (prim-exps e1) 0)
					 (to-select body counter)))))))

		 ((anf-if-p e1)
		  (append (list (gen-if-cnd (anf-if-cnd e1))
				(to-select  (anf-if-thn e1) counter)
			        (to-select (anf-if-els e1) counter))))
		 ((let-binding-p e1)
		  (let ((b2 (first (let-binding-bindings e1))))
		    (append (list (to-select (let-binding-exp e1) counter)
				  (gen-mov b1 b2))
			    (to-select (let-binding-body e1) counter)))))))	
	((prim-p cls)
	 (let ((v1 (prim-op cls))
	       (var (concatenate 'string "tmp" (format nil "~a" counter))))
	   (cond ((equalp '+ (anf-var-v v1))
		  (gen-prim-add var (prim-exps cls) 0))		
		 ((equalp '- (anf-var-v v1))
		  (gen-prim-sub var (prim-exps cls) 0))	        
		 (t
		  (gen-prim-cmp var (prim-exps cls) 0)))))
	((clos-fn-p cls)
	 (let* ((def (clos-fn-fn cls))
	        (label (anf-definition-name def)))
	   (to-select def counter)))   
	((anf-definition-p cls)
	 (let ((label (anf-definition-name cls)))
	   (make-*block* :label label :instructions (to-select (anf-definition-exp cls) counter))))))

	   
(defun gen-atomic (e1 v1) 
  (if (or (anf-num-p e1) (anf-bool-p e1))
      (make-movq :e1 (make-immediate :imm e1)
		 :e2 (make-stack-location :stk v1))
      (make-movq :e1 (make-stack-location :stk e1)
		 :e2 (make-register :reg (make-anf-var :v 'rdi)))))

(defmacro gen-prim (constructor name)
  `(defun ,name (var e1 counter)
     (let ((e2 (if (listp e1) e1 (list e1))))
       (cond ((and (anf-num-p (first e2)) (anf-num-p (second e2)))
	      (let* ((tmp (concatenate 'string "primtemp" (format nil "~a" counter)))
		     (tmp-ast (make-anf-var :v tmp)))
		(list (gen-atomic (first e2) tmp-ast)
		      (,constructor :e1 (second e2)
			            :e2 tmp-ast))))
	     ((and (anf-num-p (first e2)) (anf-var-p (second e2)))
	      (list (make-movq :e1 (first e2) :e2 (make-register :reg 'rdi))
	     ((and (anf-var-p (first e2)) (anf-num-p (second e2)))
	      (list (make-movq :e1 (first e2) :e2 (make-register :reg 'rdi))
		    (,constructor :e1 (make-register :reg 'rdi)
			          :e2 (second e2))))
	     (t (list (make-movq :e1 (first e2) :e2 (make-register :reg 'rdi))
		      (,constructor :e1 (make-register :reg 'rdi)
				  :e2 (second e2))))))))
(gen-prim make-addq gen-prim-add)
(gen-prim make-subq gen-prim-sub)
(gen-prim make-cmpq gen-prim-cmp)

(defun gen-if-cnd (cnd counter)
  (if (prim-p cnd) (gen-prim-cmp cnd) (to-select cnd counter)))

(defun gen-if (exp v1 counter)
  (cond ((atomicp exp)
	 (make-movq :e1 exp :e2 v1))	
	((prim-p exp)
	 (cond ((equalp (car (prim-exps exp)) '+)
		(gen-prim-add v1 exp counter))
	       ((equalp (car (prim-exps exp)) '-)
		(gen-prim-sub v1 exp counter))
	       (t (gen-prim-cmp v1 exp counter))))	
	(t (to-select exp counter))))
	
(defun gen-mov (v1 v2)
  (list (make-movq :e1 v2 :e2 (make-register :reg 'rdi))
	(make-movq :e1 (make-register :reg 'rdi) :e2 v1)))
